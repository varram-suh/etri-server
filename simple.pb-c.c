/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: simple.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "simple.pb-c.h"
void   sensor_data__init
                     (SensorData         *message)
{
  static const SensorData init_value = SENSOR_DATA__INIT;
  *message = init_value;
}
size_t sensor_data__get_packed_size
                     (const SensorData *message)
{
  assert(message->base.descriptor == &sensor_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t sensor_data__pack
                     (const SensorData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &sensor_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t sensor_data__pack_to_buffer
                     (const SensorData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &sensor_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
SensorData *
       sensor_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (SensorData *)
     protobuf_c_message_unpack (&sensor_data__descriptor,
                                allocator, len, data);
}
void   sensor_data__free_unpacked
                     (SensorData *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &sensor_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   sensor_set__init
                     (SensorSet         *message)
{
  static const SensorSet init_value = SENSOR_SET__INIT;
  *message = init_value;
}
size_t sensor_set__get_packed_size
                     (const SensorSet *message)
{
  assert(message->base.descriptor == &sensor_set__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t sensor_set__pack
                     (const SensorSet *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &sensor_set__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t sensor_set__pack_to_buffer
                     (const SensorSet *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &sensor_set__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
SensorSet *
       sensor_set__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (SensorSet *)
     protobuf_c_message_unpack (&sensor_set__descriptor,
                                allocator, len, data);
}
void   sensor_set__free_unpacked
                     (SensorSet *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &sensor_set__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   rough_motor_control__init
                     (RoughMotorControl         *message)
{
  static const RoughMotorControl init_value = ROUGH_MOTOR_CONTROL__INIT;
  *message = init_value;
}
size_t rough_motor_control__get_packed_size
                     (const RoughMotorControl *message)
{
  assert(message->base.descriptor == &rough_motor_control__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t rough_motor_control__pack
                     (const RoughMotorControl *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &rough_motor_control__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t rough_motor_control__pack_to_buffer
                     (const RoughMotorControl *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &rough_motor_control__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
RoughMotorControl *
       rough_motor_control__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (RoughMotorControl *)
     protobuf_c_message_unpack (&rough_motor_control__descriptor,
                                allocator, len, data);
}
void   rough_motor_control__free_unpacked
                     (RoughMotorControl *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &rough_motor_control__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   led_control__init
                     (LedControl         *message)
{
  static const LedControl init_value = LED_CONTROL__INIT;
  *message = init_value;
}
size_t led_control__get_packed_size
                     (const LedControl *message)
{
  assert(message->base.descriptor == &led_control__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t led_control__pack
                     (const LedControl *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &led_control__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t led_control__pack_to_buffer
                     (const LedControl *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &led_control__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
LedControl *
       led_control__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (LedControl *)
     protobuf_c_message_unpack (&led_control__descriptor,
                                allocator, len, data);
}
void   led_control__free_unpacked
                     (LedControl *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &led_control__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   pwm_led__init
                     (PwmLed         *message)
{
  static const PwmLed init_value = PWM_LED__INIT;
  *message = init_value;
}
size_t pwm_led__get_packed_size
                     (const PwmLed *message)
{
  assert(message->base.descriptor == &pwm_led__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t pwm_led__pack
                     (const PwmLed *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &pwm_led__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t pwm_led__pack_to_buffer
                     (const PwmLed *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &pwm_led__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
PwmLed *
       pwm_led__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (PwmLed *)
     protobuf_c_message_unpack (&pwm_led__descriptor,
                                allocator, len, data);
}
void   pwm_led__free_unpacked
                     (PwmLed *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &pwm_led__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   encoder_control__init
                     (EncoderControl         *message)
{
  static const EncoderControl init_value = ENCODER_CONTROL__INIT;
  *message = init_value;
}
size_t encoder_control__get_packed_size
                     (const EncoderControl *message)
{
  assert(message->base.descriptor == &encoder_control__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t encoder_control__pack
                     (const EncoderControl *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &encoder_control__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t encoder_control__pack_to_buffer
                     (const EncoderControl *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &encoder_control__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EncoderControl *
       encoder_control__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EncoderControl *)
     protobuf_c_message_unpack (&encoder_control__descriptor,
                                allocator, len, data);
}
void   encoder_control__free_unpacked
                     (EncoderControl *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &encoder_control__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   to_band__init
                     (ToBand         *message)
{
  static const ToBand init_value = TO_BAND__INIT;
  *message = init_value;
}
size_t to_band__get_packed_size
                     (const ToBand *message)
{
  assert(message->base.descriptor == &to_band__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t to_band__pack
                     (const ToBand *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &to_band__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t to_band__pack_to_buffer
                     (const ToBand *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &to_band__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ToBand *
       to_band__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ToBand *)
     protobuf_c_message_unpack (&to_band__descriptor,
                                allocator, len, data);
}
void   to_band__free_unpacked
                     (ToBand *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &to_band__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   to_wb55__init
                     (ToWb55         *message)
{
  static const ToWb55 init_value = TO_WB55__INIT;
  *message = init_value;
}
size_t to_wb55__get_packed_size
                     (const ToWb55 *message)
{
  assert(message->base.descriptor == &to_wb55__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t to_wb55__pack
                     (const ToWb55 *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &to_wb55__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t to_wb55__pack_to_buffer
                     (const ToWb55 *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &to_wb55__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ToWb55 *
       to_wb55__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ToWb55 *)
     protobuf_c_message_unpack (&to_wb55__descriptor,
                                allocator, len, data);
}
void   to_wb55__free_unpacked
                     (ToWb55 *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &to_wb55__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   to_st__init
                     (ToSt         *message)
{
  static const ToSt init_value = TO_ST__INIT;
  *message = init_value;
}
size_t to_st__get_packed_size
                     (const ToSt *message)
{
  assert(message->base.descriptor == &to_st__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t to_st__pack
                     (const ToSt *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &to_st__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t to_st__pack_to_buffer
                     (const ToSt *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &to_st__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ToSt *
       to_st__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ToSt *)
     protobuf_c_message_unpack (&to_st__descriptor,
                                allocator, len, data);
}
void   to_st__free_unpacked
                     (ToSt *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &to_st__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   req_complete_setup__init
                     (ReqCompleteSetup         *message)
{
  static const ReqCompleteSetup init_value = REQ_COMPLETE_SETUP__INIT;
  *message = init_value;
}
size_t req_complete_setup__get_packed_size
                     (const ReqCompleteSetup *message)
{
  assert(message->base.descriptor == &req_complete_setup__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t req_complete_setup__pack
                     (const ReqCompleteSetup *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &req_complete_setup__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t req_complete_setup__pack_to_buffer
                     (const ReqCompleteSetup *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &req_complete_setup__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ReqCompleteSetup *
       req_complete_setup__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ReqCompleteSetup *)
     protobuf_c_message_unpack (&req_complete_setup__descriptor,
                                allocator, len, data);
}
void   req_complete_setup__free_unpacked
                     (ReqCompleteSetup *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &req_complete_setup__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   ap__init
                     (Ap         *message)
{
  static const Ap init_value = AP__INIT;
  *message = init_value;
}
size_t ap__get_packed_size
                     (const Ap *message)
{
  assert(message->base.descriptor == &ap__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t ap__pack
                     (const Ap *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &ap__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t ap__pack_to_buffer
                     (const Ap *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &ap__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Ap *
       ap__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Ap *)
     protobuf_c_message_unpack (&ap__descriptor,
                                allocator, len, data);
}
void   ap__free_unpacked
                     (Ap *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &ap__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   to_hi__init
                     (ToHi         *message)
{
  static const ToHi init_value = TO_HI__INIT;
  *message = init_value;
}
size_t to_hi__get_packed_size
                     (const ToHi *message)
{
  assert(message->base.descriptor == &to_hi__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t to_hi__pack
                     (const ToHi *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &to_hi__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t to_hi__pack_to_buffer
                     (const ToHi *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &to_hi__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ToHi *
       to_hi__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ToHi *)
     protobuf_c_message_unpack (&to_hi__descriptor,
                                allocator, len, data);
}
void   to_hi__free_unpacked
                     (ToHi *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &to_hi__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   rsp_service_key__init
                     (RspServiceKey         *message)
{
  static const RspServiceKey init_value = RSP_SERVICE_KEY__INIT;
  *message = init_value;
}
size_t rsp_service_key__get_packed_size
                     (const RspServiceKey *message)
{
  assert(message->base.descriptor == &rsp_service_key__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t rsp_service_key__pack
                     (const RspServiceKey *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &rsp_service_key__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t rsp_service_key__pack_to_buffer
                     (const RspServiceKey *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &rsp_service_key__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
RspServiceKey *
       rsp_service_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (RspServiceKey *)
     protobuf_c_message_unpack (&rsp_service_key__descriptor,
                                allocator, len, data);
}
void   rsp_service_key__free_unpacked
                     (RspServiceKey *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &rsp_service_key__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   to_host__init
                     (ToHost         *message)
{
  static const ToHost init_value = TO_HOST__INIT;
  *message = init_value;
}
size_t to_host__get_packed_size
                     (const ToHost *message)
{
  assert(message->base.descriptor == &to_host__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t to_host__pack
                     (const ToHost *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &to_host__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t to_host__pack_to_buffer
                     (const ToHost *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &to_host__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ToHost *
       to_host__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ToHost *)
     protobuf_c_message_unpack (&to_host__descriptor,
                                allocator, len, data);
}
void   to_host__free_unpacked
                     (ToHost *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &to_host__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor sensor_data__field_descriptors[10] =
{
  {
    "sensor_mac_address",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(SensorData, sensor_mac_address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sensor_type",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SensorData, has_sensor_type),
    offsetof(SensorData, sensor_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sensor_temperature",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(SensorData, has_sensor_temperature),
    offsetof(SensorData, sensor_temperature),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sensor_humidity",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(SensorData, has_sensor_humidity),
    offsetof(SensorData, sensor_humidity),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eco2_ppm",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SensorData, has_eco2_ppm),
    offsetof(SensorData, eco2_ppm),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tvoc_ppb",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SensorData, has_tvoc_ppb),
    offsetof(SensorData, tvoc_ppb),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "hall_state",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(SensorData, has_hall_state),
    offsetof(SensorData, hall_state),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "hall_interrupt",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(SensorData, has_hall_interrupt),
    offsetof(SensorData, hall_interrupt),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pir_interrupt",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(SensorData, has_pir_interrupt),
    offsetof(SensorData, pir_interrupt),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sensor_voltage",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SensorData, has_sensor_voltage),
    offsetof(SensorData, sensor_voltage),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned sensor_data__field_indices_by_name[] = {
  4,   /* field[4] = eco2_ppm */
  7,   /* field[7] = hall_interrupt */
  6,   /* field[6] = hall_state */
  8,   /* field[8] = pir_interrupt */
  3,   /* field[3] = sensor_humidity */
  0,   /* field[0] = sensor_mac_address */
  2,   /* field[2] = sensor_temperature */
  1,   /* field[1] = sensor_type */
  9,   /* field[9] = sensor_voltage */
  5,   /* field[5] = tvoc_ppb */
};
static const ProtobufCIntRange sensor_data__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 10 }
};
const ProtobufCMessageDescriptor sensor_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "SensorData",
  "SensorData",
  "SensorData",
  "",
  sizeof(SensorData),
  10,
  sensor_data__field_descriptors,
  sensor_data__field_indices_by_name,
  1,  sensor_data__number_ranges,
  (ProtobufCMessageInit) sensor_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor sensor_set__field_descriptors[7] =
{
  {
    "sensor_mac_address",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(SensorSet, sensor_mac_address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sensor_type",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SensorSet, has_sensor_type),
    offsetof(SensorSet, sensor_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "interrupt_alarm",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(SensorSet, has_interrupt_alarm),
    offsetof(SensorSet, interrupt_alarm),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "notify_period",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SensorSet, has_notify_period),
    offsetof(SensorSet, notify_period),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "period_alarm",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(SensorSet, has_period_alarm),
    offsetof(SensorSet, period_alarm),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "upper_threshold",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SensorSet, has_upper_threshold),
    offsetof(SensorSet, upper_threshold),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "lower_threshold",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(SensorSet, has_lower_threshold),
    offsetof(SensorSet, lower_threshold),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned sensor_set__field_indices_by_name[] = {
  2,   /* field[2] = interrupt_alarm */
  6,   /* field[6] = lower_threshold */
  3,   /* field[3] = notify_period */
  4,   /* field[4] = period_alarm */
  0,   /* field[0] = sensor_mac_address */
  1,   /* field[1] = sensor_type */
  5,   /* field[5] = upper_threshold */
};
static const ProtobufCIntRange sensor_set__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 7 }
};
const ProtobufCMessageDescriptor sensor_set__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "SensorSet",
  "SensorSet",
  "SensorSet",
  "",
  sizeof(SensorSet),
  7,
  sensor_set__field_descriptors,
  sensor_set__field_indices_by_name,
  1,  sensor_set__number_ranges,
  (ProtobufCMessageInit) sensor_set__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor rough_motor_control__field_descriptors[2] =
{
  {
    "left_motor",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(RoughMotorControl, has_left_motor),
    offsetof(RoughMotorControl, left_motor),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "right_motor",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(RoughMotorControl, has_right_motor),
    offsetof(RoughMotorControl, right_motor),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned rough_motor_control__field_indices_by_name[] = {
  0,   /* field[0] = left_motor */
  1,   /* field[1] = right_motor */
};
static const ProtobufCIntRange rough_motor_control__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor rough_motor_control__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "RoughMotorControl",
  "RoughMotorControl",
  "RoughMotorControl",
  "",
  sizeof(RoughMotorControl),
  2,
  rough_motor_control__field_descriptors,
  rough_motor_control__field_indices_by_name,
  1,  rough_motor_control__number_ranges,
  (ProtobufCMessageInit) rough_motor_control__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor led_control__field_descriptors[3] =
{
  {
    "left",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(LedControl, has_left),
    offsetof(LedControl, left),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "right",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(LedControl, has_right),
    offsetof(LedControl, right),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "bright",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(LedControl, has_bright),
    offsetof(LedControl, bright),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned led_control__field_indices_by_name[] = {
  2,   /* field[2] = bright */
  0,   /* field[0] = left */
  1,   /* field[1] = right */
};
static const ProtobufCIntRange led_control__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor led_control__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "LedControl",
  "LedControl",
  "LedControl",
  "",
  sizeof(LedControl),
  3,
  led_control__field_descriptors,
  led_control__field_indices_by_name,
  1,  led_control__number_ranges,
  (ProtobufCMessageInit) led_control__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor pwm_led__field_descriptors[4] =
{
  {
    "pwm",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(PwmLed, has_pwm),
    offsetof(PwmLed, pwm),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "duty",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(PwmLed, has_duty),
    offsetof(PwmLed, duty),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "period",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(PwmLed, has_period),
    offsetof(PwmLed, period),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "enable",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(PwmLed, has_enable),
    offsetof(PwmLed, enable),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned pwm_led__field_indices_by_name[] = {
  1,   /* field[1] = duty */
  3,   /* field[3] = enable */
  2,   /* field[2] = period */
  0,   /* field[0] = pwm */
};
static const ProtobufCIntRange pwm_led__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor pwm_led__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "PwmLed",
  "PwmLed",
  "PwmLed",
  "",
  sizeof(PwmLed),
  4,
  pwm_led__field_descriptors,
  pwm_led__field_indices_by_name,
  1,  pwm_led__number_ranges,
  (ProtobufCMessageInit) pwm_led__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor encoder_control__field_descriptors[2] =
{
  {
    "left",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(EncoderControl, has_left),
    offsetof(EncoderControl, left),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "right",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(EncoderControl, has_right),
    offsetof(EncoderControl, right),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned encoder_control__field_indices_by_name[] = {
  0,   /* field[0] = left */
  1,   /* field[1] = right */
};
static const ProtobufCIntRange encoder_control__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor encoder_control__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EncoderControl",
  "EncoderControl",
  "EncoderControl",
  "",
  sizeof(EncoderControl),
  2,
  encoder_control__field_descriptors,
  encoder_control__field_indices_by_name,
  1,  encoder_control__number_ranges,
  (ProtobufCMessageInit) encoder_control__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor to_band__field_descriptors[9] =
{
  {
    "advertising_interval",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToBand, has_advertising_interval),
    offsetof(ToBand, advertising_interval),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tx_power",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToBand, has_tx_power),
    offsetof(ToBand, tx_power),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tag_name",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToBand, tag_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tag_phone_number",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToBand, tag_phone_number),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "lcd_angle",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToBand, has_lcd_angle),
    offsetof(ToBand, lcd_angle),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "lcd_time",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToBand, has_lcd_time),
    offsetof(ToBand, lcd_time),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "data_hz",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToBand, has_data_hz),
    offsetof(ToBand, data_hz),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "data_req",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ToBand, has_data_req),
    offsetof(ToBand, data_req),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "seq",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToBand, has_seq),
    offsetof(ToBand, seq),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned to_band__field_indices_by_name[] = {
  0,   /* field[0] = advertising_interval */
  6,   /* field[6] = data_hz */
  7,   /* field[7] = data_req */
  4,   /* field[4] = lcd_angle */
  5,   /* field[5] = lcd_time */
  8,   /* field[8] = seq */
  2,   /* field[2] = tag_name */
  3,   /* field[3] = tag_phone_number */
  1,   /* field[1] = tx_power */
};
static const ProtobufCIntRange to_band__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 9 }
};
const ProtobufCMessageDescriptor to_band__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ToBand",
  "ToBand",
  "ToBand",
  "",
  sizeof(ToBand),
  9,
  to_band__field_descriptors,
  to_band__field_indices_by_name,
  1,  to_band__number_ranges,
  (ProtobufCMessageInit) to_band__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor to_wb55__field_descriptors[11] =
{
  {
    "broadcast_interval",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToWb55, has_broadcast_interval),
    offsetof(ToWb55, broadcast_interval),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToWb55, has_power),
    offsetof(ToWb55, power),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "name",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToWb55, name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "get_st_message",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ToWb55, has_get_st_message),
    offsetof(ToWb55, get_st_message),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "seq",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToWb55, has_seq),
    offsetof(ToWb55, seq),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sensor_set",
    30,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToWb55, sensor_set),
    &sensor_set__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "to_hi_from_host",
    50,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToWb55, to_hi_from_host),
    &to_hi__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "to_host_from_hi",
    51,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToWb55, to_host_from_hi),
    &to_host__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "to_st_from_hi",
    52,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToWb55, to_st_from_hi),
    &to_st__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "to_hi_from_band",
    53,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToWb55, to_hi_from_band),
    &to_hi__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "to_st_from_host",
    54,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToWb55, to_st_from_host),
    &to_st__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned to_wb55__field_indices_by_name[] = {
  0,   /* field[0] = broadcast_interval */
  3,   /* field[3] = get_st_message */
  2,   /* field[2] = name */
  1,   /* field[1] = power */
  5,   /* field[5] = sensor_set */
  4,   /* field[4] = seq */
  9,   /* field[9] = to_hi_from_band */
  6,   /* field[6] = to_hi_from_host */
  7,   /* field[7] = to_host_from_hi */
  8,   /* field[8] = to_st_from_hi */
  10,   /* field[10] = to_st_from_host */
};
static const ProtobufCIntRange to_wb55__number_ranges[3 + 1] =
{
  { 1, 0 },
  { 30, 5 },
  { 50, 6 },
  { 0, 11 }
};
const ProtobufCMessageDescriptor to_wb55__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ToWb55",
  "ToWb55",
  "ToWb55",
  "",
  sizeof(ToWb55),
  11,
  to_wb55__field_descriptors,
  to_wb55__field_indices_by_name,
  3,  to_wb55__number_ranges,
  (ProtobufCMessageInit) to_wb55__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor to_st__field_descriptors[11] =
{
  {
    "rough_motor_control",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToSt, rough_motor_control),
    &rough_motor_control__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "encoder_control",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToSt, encoder_control),
    &encoder_control__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "led_control",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToSt, led_control),
    &led_control__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "neck_speed",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToSt, has_neck_speed),
    offsetof(ToSt, neck_speed),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "request_st_info",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToSt, has_request_st_info),
    offsetof(ToSt, request_st_info),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_command",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToSt, has_power_command),
    offsetof(ToSt, power_command),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "do_charge",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToSt, has_do_charge),
    offsetof(ToSt, do_charge),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "reset_if_no_serial",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToSt, has_reset_if_no_serial),
    offsetof(ToSt, reset_if_no_serial),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "loopback",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ToSt, has_loopback),
    offsetof(ToSt, loopback),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sensor_set",
    30,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToSt, sensor_set),
    &sensor_set__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "seq",
    99,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(ToSt, seq),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned to_st__field_indices_by_name[] = {
  6,   /* field[6] = do_charge */
  1,   /* field[1] = encoder_control */
  2,   /* field[2] = led_control */
  8,   /* field[8] = loopback */
  3,   /* field[3] = neck_speed */
  5,   /* field[5] = power_command */
  4,   /* field[4] = request_st_info */
  7,   /* field[7] = reset_if_no_serial */
  0,   /* field[0] = rough_motor_control */
  9,   /* field[9] = sensor_set */
  10,   /* field[10] = seq */
};
static const ProtobufCIntRange to_st__number_ranges[4 + 1] =
{
  { 2, 0 },
  { 6, 3 },
  { 30, 9 },
  { 99, 10 },
  { 0, 11 }
};
const ProtobufCMessageDescriptor to_st__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ToSt",
  "ToSt",
  "ToSt",
  "",
  sizeof(ToSt),
  11,
  to_st__field_descriptors,
  to_st__field_indices_by_name,
  4,  to_st__number_ranges,
  (ProtobufCMessageInit) to_st__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor req_complete_setup__field_descriptors[2] =
{
  {
    "user_id",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ReqCompleteSetup, user_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "device_id",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ReqCompleteSetup, device_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned req_complete_setup__field_indices_by_name[] = {
  1,   /* field[1] = device_id */
  0,   /* field[0] = user_id */
};
static const ProtobufCIntRange req_complete_setup__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor req_complete_setup__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ReqCompleteSetup",
  "ReqCompleteSetup",
  "ReqCompleteSetup",
  "",
  sizeof(ReqCompleteSetup),
  2,
  req_complete_setup__field_descriptors,
  req_complete_setup__field_indices_by_name,
  1,  req_complete_setup__number_ranges,
  (ProtobufCMessageInit) req_complete_setup__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor ap__field_descriptors[2] =
{
  {
    "ssid",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Ap, ssid),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ssid_type",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Ap, ssid_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned ap__field_indices_by_name[] = {
  0,   /* field[0] = ssid */
  1,   /* field[1] = ssid_type */
};
static const ProtobufCIntRange ap__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor ap__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Ap",
  "Ap",
  "Ap",
  "",
  sizeof(Ap),
  2,
  ap__field_descriptors,
  ap__field_indices_by_name,
  1,  ap__number_ranges,
  (ProtobufCMessageInit) ap__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor to_hi__field_descriptors[48] =
{
  {
    "tohost_bypass",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToHi, tohost_bypass),
    &to_host__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tost_bypass",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToHi, tost_bypass),
    &to_st__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "status",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_status),
    offsetof(ToHi, status),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tof",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_tof),
    offsetof(ToHi, tof),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "accx",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(ToHi, has_accx),
    offsetof(ToHi, accx),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "accy",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(ToHi, has_accy),
    offsetof(ToHi, accy),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "accz",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(ToHi, has_accz),
    offsetof(ToHi, accz),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "gyro_x",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(ToHi, has_gyro_x),
    offsetof(ToHi, gyro_x),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "gyro_y",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(ToHi, has_gyro_y),
    offsetof(ToHi, gyro_y),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "gyro_z",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(ToHi, has_gyro_z),
    offsetof(ToHi, gyro_z),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "yaw",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(ToHi, has_yaw),
    offsetof(ToHi, yaw),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pitch",
    12,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(ToHi, has_pitch),
    offsetof(ToHi, pitch),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "roll",
    13,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(ToHi, has_roll),
    offsetof(ToHi, roll),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "battery",
    14,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(ToHi, has_battery),
    offsetof(ToHi, battery),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "hopadc",
    15,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_hopadc),
    offsetof(ToHi, hopadc),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "lspeed",
    16,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(ToHi, has_lspeed),
    offsetof(ToHi, lspeed),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "rspeed",
    17,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(ToHi, has_rspeed),
    offsetof(ToHi, rspeed),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "t_speed",
    18,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(ToHi, has_t_speed),
    offsetof(ToHi, t_speed),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "lenc",
    19,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(ToHi, has_lenc),
    offsetof(ToHi, lenc),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "renc",
    20,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(ToHi, has_renc),
    offsetof(ToHi, renc),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "power_button_pressed",
    21,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ToHi, has_power_button_pressed),
    offsetof(ToHi, power_button_pressed),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "usb_con",
    22,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ToHi, has_usb_con),
    offsetof(ToHi, usb_con),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "charge_complete",
    23,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ToHi, has_charge_complete),
    offsetof(ToHi, charge_complete),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "auto_charge_step",
    24,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_auto_charge_step),
    offsetof(ToHi, auto_charge_step),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "loopback",
    25,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ToHi, has_loopback),
    offsetof(ToHi, loopback),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "mac_address",
    50,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToHi, mac_address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dev_name",
    51,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToHi, dev_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "dev_rssi",
    52,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_dev_rssi),
    offsetof(ToHi, dev_rssi),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "connected",
    53,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ToHi, has_connected),
    offsetof(ToHi, connected),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "connected_mac",
    54,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToHi, connected_mac),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "disconnected",
    55,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(ToHi, has_disconnected),
    offsetof(ToHi, disconnected),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "disconnected_mac",
    56,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToHi, disconnected_mac),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "phone_public_key",
    100,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToHi, phone_public_key),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "do_charge",
    101,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_do_charge),
    offsetof(ToHi, do_charge),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "video_seq",
    102,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_video_seq),
    offsetof(ToHi, video_seq),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "set_ir_cut1",
    110,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_set_ir_cut1),
    offsetof(ToHi, set_ir_cut1),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "set_ir_cut2",
    111,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_set_ir_cut2),
    offsetof(ToHi, set_ir_cut2),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "set_mute",
    113,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(ToHi, has_set_mute),
    offsetof(ToHi, set_mute),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "audio",
    114,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ToHi, has_audio),
    offsetof(ToHi, audio),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ssid",
    200,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToHi, ssid),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ssid_password",
    201,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToHi, ssid_password),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ssid_type",
    202,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToHi, ssid_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "req_service_key",
    203,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_req_service_key),
    offsetof(ToHi, req_service_key),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "req_complete_setup",
    204,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToHi, req_complete_setup),
    &req_complete_setup__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "req_scan_ap",
    205,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_req_scan_ap),
    offsetof(ToHi, req_scan_ap),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "pwm_led",
    300,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToHi, pwm_led),
    &pwm_led__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "seq",
    999,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHi, has_seq),
    offsetof(ToHi, seq),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sender",
    1000,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ToHi, sender),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned to_hi__field_indices_by_name[] = {
  4,   /* field[4] = accx */
  5,   /* field[5] = accy */
  6,   /* field[6] = accz */
  38,   /* field[38] = audio */
  23,   /* field[23] = auto_charge_step */
  13,   /* field[13] = battery */
  22,   /* field[22] = charge_complete */
  28,   /* field[28] = connected */
  29,   /* field[29] = connected_mac */
  26,   /* field[26] = dev_name */
  27,   /* field[27] = dev_rssi */
  30,   /* field[30] = disconnected */
  31,   /* field[31] = disconnected_mac */
  33,   /* field[33] = do_charge */
  7,   /* field[7] = gyro_x */
  8,   /* field[8] = gyro_y */
  9,   /* field[9] = gyro_z */
  14,   /* field[14] = hopadc */
  18,   /* field[18] = lenc */
  24,   /* field[24] = loopback */
  15,   /* field[15] = lspeed */
  25,   /* field[25] = mac_address */
  32,   /* field[32] = phone_public_key */
  11,   /* field[11] = pitch */
  20,   /* field[20] = power_button_pressed */
  45,   /* field[45] = pwm_led */
  19,   /* field[19] = renc */
  43,   /* field[43] = req_complete_setup */
  44,   /* field[44] = req_scan_ap */
  42,   /* field[42] = req_service_key */
  12,   /* field[12] = roll */
  16,   /* field[16] = rspeed */
  47,   /* field[47] = sender */
  46,   /* field[46] = seq */
  35,   /* field[35] = set_ir_cut1 */
  36,   /* field[36] = set_ir_cut2 */
  37,   /* field[37] = set_mute */
  39,   /* field[39] = ssid */
  40,   /* field[40] = ssid_password */
  41,   /* field[41] = ssid_type */
  2,   /* field[2] = status */
  17,   /* field[17] = t_speed */
  3,   /* field[3] = tof */
  0,   /* field[0] = tohost_bypass */
  1,   /* field[1] = tost_bypass */
  21,   /* field[21] = usb_con */
  34,   /* field[34] = video_seq */
  10,   /* field[10] = yaw */
};
static const ProtobufCIntRange to_hi__number_ranges[8 + 1] =
{
  { 1, 0 },
  { 50, 25 },
  { 100, 32 },
  { 110, 35 },
  { 113, 37 },
  { 200, 39 },
  { 300, 45 },
  { 999, 46 },
  { 0, 48 }
};
const ProtobufCMessageDescriptor to_hi__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ToHi",
  "ToHi",
  "ToHi",
  "",
  sizeof(ToHi),
  48,
  to_hi__field_descriptors,
  to_hi__field_indices_by_name,
  8,  to_hi__number_ranges,
  (ProtobufCMessageInit) to_hi__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor rsp_service_key__field_descriptors[4] =
{
  {
    "service_key",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(RspServiceKey, service_key),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "mac_address",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(RspServiceKey, mac_address),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "model_name",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(RspServiceKey, model_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "serial_number",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(RspServiceKey, serial_number),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned rsp_service_key__field_indices_by_name[] = {
  1,   /* field[1] = mac_address */
  2,   /* field[2] = model_name */
  3,   /* field[3] = serial_number */
  0,   /* field[0] = service_key */
};
static const ProtobufCIntRange rsp_service_key__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor rsp_service_key__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "RspServiceKey",
  "RspServiceKey",
  "RspServiceKey",
  "",
  sizeof(RspServiceKey),
  4,
  rsp_service_key__field_descriptors,
  rsp_service_key__field_indices_by_name,
  1,  rsp_service_key__number_ranges,
  (ProtobufCMessageInit) rsp_service_key__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor to_host__field_descriptors[8] =
{
  {
    "video",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ToHost, has_video),
    offsetof(ToHost, video),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "audio",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    offsetof(ToHost, has_audio),
    offsetof(ToHost, audio),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tohi_bypass",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToHost, tohi_bypass),
    &to_hi__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sensor_data",
    62,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToHost, sensor_data),
    &sensor_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "rsp_service_key",
    100,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(ToHost, rsp_service_key),
    &rsp_service_key__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "rsp_complete_setup",
    101,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ToHost, has_rsp_complete_setup),
    offsetof(ToHost, rsp_complete_setup),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ap_list",
    102,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(ToHost, n_ap_list),
    offsetof(ToHost, ap_list),
    &ap__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ap_connection_result",
    103,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    offsetof(ToHost, has_ap_connection_result),
    offsetof(ToHost, ap_connection_result),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned to_host__field_indices_by_name[] = {
  7,   /* field[7] = ap_connection_result */
  6,   /* field[6] = ap_list */
  1,   /* field[1] = audio */
  5,   /* field[5] = rsp_complete_setup */
  4,   /* field[4] = rsp_service_key */
  3,   /* field[3] = sensor_data */
  2,   /* field[2] = tohi_bypass */
  0,   /* field[0] = video */
};
static const ProtobufCIntRange to_host__number_ranges[4 + 1] =
{
  { 1, 0 },
  { 8, 2 },
  { 62, 3 },
  { 100, 4 },
  { 0, 8 }
};
const ProtobufCMessageDescriptor to_host__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ToHost",
  "ToHost",
  "ToHost",
  "",
  sizeof(ToHost),
  8,
  to_host__field_descriptors,
  to_host__field_indices_by_name,
  4,  to_host__number_ranges,
  (ProtobufCMessageInit) to_host__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCEnumValue st_info__enum_values_by_number[9] =
{
  { "STATUS", "ST_INFO__STATUS", 1 },
  { "TOF", "ST_INFO__TOF", 2 },
  { "ACC", "ST_INFO__ACC", 4 },
  { "GYRO", "ST_INFO__GYRO", 8 },
  { "IMU", "ST_INFO__IMU", 16 },
  { "HOP", "ST_INFO__HOP", 32 },
  { "MOTOR", "ST_INFO__MOTOR", 64 },
  { "ENC", "ST_INFO__ENC", 128 },
  { "BATTERY", "ST_INFO__BATTERY", 256 },
};
static const ProtobufCIntRange st_info__value_ranges[] = {
{1, 0},{4, 2},{8, 3},{16, 4},{32, 5},{64, 6},{128, 7},{256, 8},{0, 9}
};
static const ProtobufCEnumValueIndex st_info__enum_values_by_name[9] =
{
  { "ACC", 2 },
  { "BATTERY", 8 },
  { "ENC", 7 },
  { "GYRO", 3 },
  { "HOP", 5 },
  { "IMU", 4 },
  { "MOTOR", 6 },
  { "STATUS", 0 },
  { "TOF", 1 },
};
const ProtobufCEnumDescriptor st_info__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "StInfo",
  "StInfo",
  "StInfo",
  "",
  9,
  st_info__enum_values_by_number,
  9,
  st_info__enum_values_by_name,
  8,
  st_info__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
